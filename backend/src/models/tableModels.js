const DB_Connection = require("../database/db.js");
const { runWithLogging } = require("../utils/runWithLogging.js");

const table_query = `
-- ENUMs
    DO $$ BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'student_status_enum') THEN
            CREATE TYPE student_status_enum AS ENUM ('Active', 'Graduated', 'Paused');
        END IF;
        IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'course_type_enum') THEN
            CREATE TYPE course_type_enum AS ENUM ('Theory', 'Lab');
        END IF;
        IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'enrollment_status_enum') THEN
            CREATE TYPE enrollment_status_enum AS ENUM ('Pending', 'Enrolled', 'Withdrawn');
        END IF;
    END $$;
    
    DROP TYPE IF EXISTS marking_type_enum CASCADE;
    CREATE TYPE marking_type_enum AS ENUM ('Midterm', 'Final', 'CT', 'Attendance');
    
    DO $$ BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'marking_status_enum') THEN
            CREATE TYPE marking_status_enum AS ENUM ('Published', 'Draft');
        END IF;
        IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'payment_method_enum') THEN
            CREATE TYPE payment_method_enum AS ENUM ('Mobile Banking', 'Bank Transfer');
        END IF;
        IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'payment_status_enum') THEN
            CREATE TYPE payment_status_enum AS ENUM ('Paid', 'Partial', 'Overdue');
        END IF;
        IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'appointment_type_enum') THEN
            CREATE TYPE appointment_type_enum AS ENUM ('Lecturer', 'Assistant Professor', 'Associate Professor', 'Professor');
        END IF;
    END $$;

    CREATE TABLE IF NOT EXISTS users (
        id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
        name VARCHAR(255) NOT NULL,
        email VARCHAR(255) UNIQUE NOT NULL,
        password_hash VARCHAR(255) NOT NULL,
        role VARCHAR(20) DEFAULT 'Student',
        refresh_token TEXT,
        mobile_number VARCHAR(20),
        mobile_banking_number VARCHAR(20),
        bank_account_number VARCHAR(50),
        permanent_address TEXT,
        present_address TEXT NOT NULL,
        birth_reg_number VARCHAR(50) NOT NULL,
        nid_number VARCHAR(50),
        passport_number VARCHAR(50),
        birth_date DATE NOT NULL,
        emergency_contact_name VARCHAR(255),
        emergency_contact_number VARCHAR(20) NOT NULL,
        emergency_contact_relation VARCHAR(50),
        CONSTRAINT payment_constraint CHECK (bank_account_number IS NOT NULL OR mobile_banking_number IS NOT NULL),
        CONSTRAINT identification_constraint CHECK (passport_number IS NOT NULL OR nid_number IS NOT NULL)
    );

    CREATE TABLE IF NOT EXISTS departments (
        id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
        code VARCHAR(20) UNIQUE,
        name VARCHAR(255) NOT NULL,
        department_head_id INT
    );

    CREATE TABLE IF NOT EXISTS terms (
        id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
        term_number INT NOT NULL,
        start_date DATE NOT NULL,
        end_date DATE NOT NULL,
        department_id INTEGER REFERENCES departments(id) NOT NULL
    );
        ALTER TABLE terms ADD CONSTRAINT unique_term_per_dept_start UNIQUE (term_number, department_id, start_date);

    CREATE TABLE IF NOT EXISTS teachers (
        user_id INT PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
        appointment appointment_type_enum,
        official_mail VARCHAR(255),
        department_id INT REFERENCES departments(id)
    );

    CREATE TABLE IF NOT EXISTS students (
        user_id INT PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
        roll_number VARCHAR(20) UNIQUE NOT NULL,
        official_mail VARCHAR(255),
        status student_status_enum DEFAULT 'Active',
        current_term INTEGER REFERENCES terms(id)
    );

    CREATE TABLE IF NOT EXISTS department_heads (
        department_id INTEGER REFERENCES departments(id),
        teacher_id INTEGER REFERENCES teachers(user_id),
        CONSTRAINT dept_head_pk PRIMARY KEY (department_id, teacher_id)
    );

    CREATE TABLE IF NOT EXISTS student_term_history (
        id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
        student_id INTEGER REFERENCES students(user_id) ON DELETE CASCADE,
        term_id INTEGER REFERENCES terms(id) ON DELETE CASCADE,
        start_date DATE,
        end_date DATE
    );

    CREATE TABLE IF NOT EXISTS courses (
        id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
        course_code VARCHAR(20) UNIQUE NOT NULL, 
        name VARCHAR(255) NOT NULL,
        credit_hours DECIMAL(3, 1) NOT NULL,
        type course_type_enum,
        department_id INTEGER REFERENCES departments(id) NOT NULL
    );

    CREATE TABLE IF NOT EXISTS course_prerequisites (
        course_id INTEGER REFERENCES courses(id),
        prereq_id INTEGER REFERENCES courses(id),
        PRIMARY KEY (course_id, prereq_id)
    );

    CREATE TABLE IF NOT EXISTS course_offerings (
        id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
        term_id INT REFERENCES terms(id) NOT NULL,
        course_id INTEGER REFERENCES courses(id) NOT NULL,
        max_capacity INT,
        UNIQUE(term_id, course_id)
    );

    CREATE TABLE IF NOT EXISTS sections (
        term_id INTEGER REFERENCES terms(id), 
        name VARCHAR(50),
        UNIQUE(term_id, name)
    );

    CREATE TABLE IF NOT EXISTS teaches (
        course_offering_id INTEGER REFERENCES course_offerings(id),
        teacher_id INTEGER REFERENCES teachers(user_id),
        section_name VARCHAR(50)
    );

    CREATE TABLE IF NOT EXISTS student_sections (
        student_id INTEGER REFERENCES students(user_id),
        section_name VARCHAR(50)
    );

    CREATE TABLE IF NOT EXISTS student_advisor_history (
        id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
        student_id INT REFERENCES students(user_id),
        teacher_id INT REFERENCES teachers(user_id),
        start_date DATE,
        end_date DATE,
        change_reason TEXT
    );

    CREATE TABLE IF NOT EXISTS student_enrollments (
        id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
        student_id INT REFERENCES students(user_id),
        course_offering_id INT REFERENCES course_offerings(id),
        credit_when_taking DECIMAL(3, 1),
        status enrollment_status_enum DEFAULT 'Pending',
        enrollment_timestamp TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
        approved_timestamp TIMESTAMPTZ,
        grade VARCHAR(5),
        is_retake BOOLEAN DEFAULT FALSE,
        approved_by_teacher_id INT REFERENCES teachers(user_id)
    );

    CREATE TABLE IF NOT EXISTS marking_components (
        id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
        enrollment_id INT REFERENCES student_enrollments(id) ON DELETE CASCADE,
        type marking_type_enum,
        total_marks DECIMAL(5, 2),
        marks_obtained DECIMAL(5, 2),
        status marking_status_enum DEFAULT 'Draft'
    );

    CREATE TABLE IF NOT EXISTS dues (
        id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
        name VARCHAR(100), 
        amount DECIMAL(10, 2) NOT NULL,
        bank_account_number VARCHAR(50) 
    );

    CREATE TABLE IF NOT EXISTS student_dues_payment (
        id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
        student_id INT REFERENCES students(user_id),
        due_id INT REFERENCES dues(id),
        amount_paid DECIMAL(10, 2) DEFAULT 0,
        paid_at TIMESTAMPTZ,
        payment_method payment_method_enum,
        mobile_banking_number VARCHAR(20),
        status payment_status_enum DEFAULT 'Overdue',
        deadline DATE
    );

    CREATE TABLE IF NOT EXISTS feedback (
        id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
        course_offering_id INTEGER REFERENCES course_offerings(id),
        teacher_id INT REFERENCES teachers(user_id), 
        csv_file_url TEXT,
        average_rating DECIMAL(3, 2)
    );
 
     
    -- Trigger function to enforce limits per enrollment (only Published)
CREATE OR REPLACE FUNCTION trg_marking_components_limits()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
DECLARE
    existing_ct_count INT;
    existing_att_count INT;
    existing_final_count INT;
    exclude_id INT := NULL;
BEGIN
    IF TG_OP = 'UPDATE' THEN
        exclude_id := OLD.id;
    END IF;

    -- Count existing Published components for the same enrollment, excluding the current row if updating
    SELECT COUNT(*) INTO existing_ct_count
    FROM marking_components
    WHERE enrollment_id = NEW.enrollment_id
      AND status = 'Published'
      AND type = 'CT'
      AND (id IS DISTINCT FROM exclude_id);

    SELECT COUNT(*) INTO existing_att_count
    FROM marking_components
    WHERE enrollment_id = NEW.enrollment_id
      AND status = 'Published'
      AND type = 'Attendance'
      AND (id IS DISTINCT FROM exclude_id);

    SELECT COUNT(*) INTO existing_final_count
    FROM marking_components
    WHERE enrollment_id = NEW.enrollment_id
      AND status = 'Published'
      AND type = 'Final'
      AND (id IS DISTINCT FROM exclude_id);

    -- If NEW will be Published, check the incremented counts
    IF NEW.status = 'Published' THEN
        IF NEW.type = 'CT' THEN
            IF existing_ct_count + 1 > 4 THEN
                RAISE EXCEPTION 'Limit exceeded: enrollment_id=% already has % Published CT components; max allowed is 4.',
                    NEW.enrollment_id, existing_ct_count;
            END IF;
        ELSIF NEW.type = 'Attendance' THEN
            IF existing_att_count + 1 > 1 THEN
                RAISE EXCEPTION 'Limit exceeded: enrollment_id=% already has % Published Attendance components; max allowed is 1.',
                    NEW.enrollment_id, existing_att_count;
            END IF;
        ELSIF NEW.type = 'Final' THEN
            IF existing_final_count + 1 > 1 THEN
                RAISE EXCEPTION 'Limit exceeded: enrollment_id=% already has % Published Final components; max allowed is 1.',
                    NEW.enrollment_id, existing_final_count;
            END IF;
        ELSE
            -- For other types, still ensure existing data is not already violating limits
            IF existing_ct_count > 4 THEN
                RAISE EXCEPTION 'Existing data violation: enrollment_id=% has % Published CT components (>4).', NEW.enrollment_id, existing_ct_count;
            END IF;
            IF existing_att_count > 1 THEN
                RAISE EXCEPTION 'Existing data violation: enrollment_id=% has % Published Attendance components (>1).', NEW.enrollment_id, existing_att_count;
            END IF;
            IF existing_final_count > 1 THEN
                RAISE EXCEPTION 'Existing data violation: enrollment_id=% has % Published Final components (>1).', NEW.enrollment_id, existing_final_count;
            END IF;
        END IF;
    ELSE
        -- NEW is not Published: still block if existing published rows already violate limits
        IF existing_ct_count > 4 THEN
            RAISE EXCEPTION 'Existing data violation: enrollment_id=% has % Published CT components (>4).', NEW.enrollment_id, existing_ct_count;
        END IF;
        IF existing_att_count > 1 THEN
            RAISE EXCEPTION 'Existing data violation: enrollment_id=% has % Published Attendance components (>1).', NEW.enrollment_id, existing_att_count;
        END IF;
        IF existing_final_count > 1 THEN
            RAISE EXCEPTION 'Existing data violation: enrollment_id=% has % Published Final components (>1).', NEW.enrollment_id, existing_final_count;
        END IF;
    END IF;

    RETURN NEW;
END;
$$;

-- Attach the trigger to marking_components
DROP TRIGGER IF EXISTS marking_components_limits_trg ON marking_components;

CREATE TRIGGER marking_components_limits_trg
BEFORE INSERT OR UPDATE ON marking_components
FOR EACH ROW
EXECUTE FUNCTION trg_marking_components_limits();


CREATE OR REPLACE FUNCTION compile_student_term_result(p_student_id INT, p_term_id INT)
RETURNS TABLE (
    enrollment_id INT,
    course_offering_id INT,
    course_id INT,
    course_code VARCHAR,
    course_name VARCHAR,
    ct_best3_score NUMERIC(8,2),
    attendance_score NUMERIC(8,2),
    final_score NUMERIC(8,2),
    total_score NUMERIC(8,2),
    percentage NUMERIC(5,2),
    grade VARCHAR
)
LANGUAGE sql
AS $$
WITH enrolls AS (
    SELECT se.id AS enrollment_id,
           se.course_offering_id
    FROM student_enrollments se
    JOIN course_offerings co ON se.course_offering_id = co.id
    WHERE se.student_id = p_student_id
      AND co.term_id = p_term_id
),
published_marks AS (
    SELECT mc.id,
           mc.enrollment_id,
           mc.type,
           COALESCE(mc.total_marks, 0) AS total_marks,
           COALESCE(mc.marks_obtained, 0) AS marks_obtained,
           CASE
             WHEN mc.type = 'CT' THEN
               CASE WHEN COALESCE(mc.total_marks,0) = 0 THEN 0
                    ELSE (COALESCE(mc.marks_obtained,0)::numeric / COALESCE(mc.total_marks,0)::numeric) * 20.0
               END
             WHEN mc.type = 'Attendance' THEN
               CASE WHEN COALESCE(mc.total_marks,0) = 0 THEN 0
                    ELSE (COALESCE(mc.marks_obtained,0)::numeric / COALESCE(mc.total_marks,0)::numeric) * 30.0
               END
             WHEN mc.type = 'Final' THEN
               CASE WHEN COALESCE(mc.total_marks,0) = 0 THEN 0
                    ELSE (COALESCE(mc.marks_obtained,0)::numeric / COALESCE(mc.total_marks,0)::numeric) * 210.0
               END
             ELSE 0
           END AS normalized_score
    FROM marking_components mc
    JOIN enrolls e ON mc.enrollment_id = e.enrollment_id
    WHERE mc.status = 'Published'
),
ct_ranked AS (
    SELECT pm.*,
           ROW_NUMBER() OVER (PARTITION BY pm.enrollment_id ORDER BY pm.normalized_score DESC, pm.id) AS rn
    FROM published_marks pm
    WHERE pm.type = 'CT'
),
ct_best3 AS (
    SELECT enrollment_id,
           COALESCE(SUM(normalized_score),0)::numeric(8,2) AS ct_best3_score
    FROM ct_ranked
    WHERE rn <= 3
    GROUP BY enrollment_id
),
attendance_sum AS (
    SELECT enrollment_id,
           COALESCE(SUM(normalized_score),0)::numeric(8,2) AS attendance_score
    FROM published_marks
    WHERE type = 'Attendance'
    GROUP BY enrollment_id
),
final_sum AS (
    SELECT enrollment_id,
           COALESCE(SUM(normalized_score),0)::numeric(8,2) AS final_score
    FROM published_marks
    WHERE type = 'Final'
    GROUP BY enrollment_id
)
SELECT
    e.enrollment_id,
    e.course_offering_id,
    c.id AS course_id,
    c.course_code,
    c.name AS course_name,
    COALESCE(ct.ct_best3_score, 0) AS ct_best3_score,
    COALESCE(att.attendance_score, 0) AS attendance_score,
    COALESCE(fin.final_score, 0) AS final_score,
    (COALESCE(ct.ct_best3_score,0) + COALESCE(att.attendance_score,0) + COALESCE(fin.final_score,0))::numeric(8,2) AS total_score,
    ROUND( ( (COALESCE(ct.ct_best3_score,0) + COALESCE(att.attendance_score,0) + COALESCE(fin.final_score,0)) / 300.0 ) * 100.0, 2) AS percentage,
    CASE
      WHEN ( (COALESCE(ct.ct_best3_score,0) + COALESCE(att.attendance_score,0) + COALESCE(fin.final_score,0)) / 300.0 ) * 100.0 >= 80 THEN 'A+'
      WHEN ( (COALESCE(ct.ct_best3_score,0) + COALESCE(att.attendance_score,0) + COALESCE(fin.final_score,0)) / 300.0 ) * 100.0 >= 75 THEN 'A'
      WHEN ( (COALESCE(ct.ct_best3_score,0) + COALESCE(att.attendance_score,0) + COALESCE(fin.final_score,0)) / 300.0 ) * 100.0 >= 70 THEN 'A-'
      WHEN ( (COALESCE(ct.ct_best3_score,0) + COALESCE(att.attendance_score,0) + COALESCE(fin.final_score,0)) / 300.0 ) * 100.0 >= 65 THEN 'B'
      WHEN ( (COALESCE(ct.ct_best3_score,0) + COALESCE(att.attendance_score,0) + COALESCE(fin.final_score,0)) / 300.0 ) * 100.0 >= 60 THEN 'C'
      WHEN ( (COALESCE(ct.ct_best3_score,0) + COALESCE(att.attendance_score,0) + COALESCE(fin.final_score,0)) / 300.0 ) * 100.0 >= 55 THEN 'D'
      ELSE 'F'
    END AS grade
FROM enrolls e
LEFT JOIN courses c ON c.id = (SELECT co.course_id FROM course_offerings co WHERE co.id = e.course_offering_id)
LEFT JOIN ct_best3 ct ON ct.enrollment_id = e.enrollment_id
LEFT JOIN attendance_sum att ON att.enrollment_id = e.enrollment_id
LEFT JOIN final_sum fin ON fin.enrollment_id = e.enrollment_id
ORDER BY c.course_code;
$$;

CREATE TABLE IF NOT EXISTS current_state (
        reg_start DATE,
        reg_end DATE,
        newest_term_start DATE
    );
`

class TableModel {
    constructor() {
        this.db = DB_Connection.getInstance();
    }

    initalizeTables = async () => {
        return await runWithLogging(
            'Table Creation',
            async () => {
                const result = await this.db.query_executor(table_query);
                return result;
            }
        );
    }

    testConnection = async (req, res) => {
        const query = ' SELECT 1 ;'
        return await runWithLogging(
            'DB connection test',
            async () => {
                const result = await this.db.query_executor(query);
                return result;
            }
        )
    }
}

module.exports = TableModel;